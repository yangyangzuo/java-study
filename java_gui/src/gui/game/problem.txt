常见问题：

原则：
凡是牵涉到画图的操作，都放在paint方法中，如果是动态的改变图形的话，
可以写个方法，然后在paint方法中调用图形参数移动的方法(参考Tank.java文件中的move方法，画炮筒的操作)

1。图象屏幕闪烁：解决办法双缓冲

2。 键盘事件线程可能不能及时响应，出现的情况是：摁下一个键后，物体移动一下，卡一下，在继续连续移动。
解决方法：在摁下键的时候只让物体改变方向，在定义一个函数中来改变物体位置的值，在paint方法中调用这个函数
但是，这样也不能完全解决问题。有这样一种情况：
如果你设定了摁一个键后，物体朝一个方向移动，暂且让他一直移动，发现，他移动的很 平滑，并不会象刚开始摁的是时候卡一下
再平滑的移动，所以这里在停止他移动的时候也用键盘监听，监听他摁键离开的时候在取消他的移动
牵涉到键盘问题的分析：
(凡是牵涉到画图的操作在paint方法中被调用了，可以时时改变，而键盘时间方法有后台的线程运行，运行不规律，
事件就不平滑，修改值的时候可能不及时，所以再画的时候可能不能及时相应，而在paint方法中修改，每次重画都会修改，很及时)


3. 可变窗口的游戏，对双缓冲图片尺寸的大小要根据窗口的大小动态的改变，参考DoubleBuffer5和DoubleBuffer6


4. 内存消耗问题，如果所画的图形超出了框架的大小，或者图形在过程中消失了，那么就取消他，不用再画了，如果一直画着，
会一直消耗内存，有可能使系统内存用尽,一种方法是每次画图形的时候，判断是不是消失了，另一种方法是创建一个后台线程定期清楚不需要画的东西


5. 碰撞检测,一般使用特定的类库，碰撞检测算法比较难
常见的碰撞解决方法：在下一贞和上一贞之间，记录上一贞的所画的位子，如果发生了碰撞，就把相应的坐标还原为记录的值,参考坦克和墙碰撞的例子

6.角色死亡/消亡的动画效果：将特定的图片在消亡的地点逐步画出

7.图形的刷新率：即游戏画面重画的间隔时间，时间越短，画面越细腻，但是占用cpu越多
